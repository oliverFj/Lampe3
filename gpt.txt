How does colorWaveVisualization.js get the gyroscope data from dataManager? I want to create more visualizations, so can this be more generally accecible? 

//dataManager.js
export default class DataManager {
    constructor() {
        this.devices = {};
        this.colorCount = { red: 0, green: 0, blue: 0 };
        this.colorWeights = {};
        this.disconnectTimeout = 6000;
    }

    getColorFromValue(value) {
        switch (value) {
            case 1: return 'red';
            case 2: return 'green';
            case 3: return 'blue';
            default: return 'unknown';
        }
    }

    calculateWeight(beta) {
        let cappedBeta = Math.min(Math.max(beta, -90), 90);
        let normalizedBeta = (cappedBeta + 90) / 180;
        let weight = normalizedBeta;
        console.log(`Calculated weight for beta ${beta}: ${weight}`);
        return weight;
    }

    recalculateColorCounts() {
        let newCounts = { red: 0, green: 0, blue: 0 };
        Object.values(this.colorWeights).forEach(entry => {
            newCounts[entry.color] += entry.weight;
        });

        Object.keys(this.colorCount).forEach(color => {
            this.colorCount[color] = newCounts[color] / Object.values(this.colorWeights).filter(e => e.color === color).length || 0;
        });

        console.log(`Updated color counts: Red - ${this.colorCount.red.toFixed(2)}, Green - ${this.colorCount.green.toFixed(2)}, Blue - ${this.colorCount.blue.toFixed(2)}`);
    }

    updateColorCount(deviceId, color, weight, isAdding = true) {
        if (isAdding) {
            this.colorWeights[deviceId] = { color, weight };
        } else {
            delete this.colorWeights[deviceId];
        }
        this.recalculateColorCounts();
    }

    manageDevice(message) {
        console.log("Managing device:", message);
        let deviceId = message.from;
        let newColorValue = this.getColorFromValue(message.colorValue);
        let newWeight = this.calculateWeight(message.beta);

        if (!this.devices[deviceId]) {
            console.log(`Adding new device: ${deviceId}`);
            this.devices[deviceId] = {
                ...message,
                color: newColorValue,
                weight: newWeight,
                timer: setTimeout(() => this.removeDevice(deviceId), this.disconnectTimeout),
            };
            this.updateColorCount(deviceId, newColorValue, newWeight, true);
        } else {
            clearTimeout(this.devices[deviceId].timer);
            this.devices[deviceId].timer = setTimeout(() => this.removeDevice(deviceId), this.disconnectTimeout);
            let currentColor = this.devices[deviceId].color;
            let currentWeight = this.devices[deviceId].weight;

            // Update device info
            this.devices[deviceId] = {...this.devices[deviceId], ...message, weight: newWeight};

            if (currentColor !== newColorValue) {
                this.updateColorCount(deviceId, currentColor, currentWeight, false);
                this.updateColorCount(deviceId, newColorValue, newWeight, true);
            } else if (currentWeight !== newWeight) {
                this.updateColorCount(deviceId, currentColor, currentWeight, false);
                this.updateColorCount(deviceId, newColorValue, newWeight, true);
            }
        }
    }

    removeDevice(deviceId) {
        if (this.devices[deviceId]) {
            console.log(`Removing inactive device: ${deviceId}`);
            let { color, weight } = this.devices[deviceId];
            this.updateColorCount(deviceId, color, weight, false);
            delete this.devices[deviceId];
            console.log(`Device ${deviceId} removed. Current device count: ${Object.keys(this.devices).length}`);
        }
    }
}


//colorWaveVisualization.js
import Visualization from './visualization.js';

export default class ColorWaveVisualization extends Visualization {
    constructor(p, dataManager) {
        super(p, dataManager);
        this.waves = [];
        this.lastColor = {};
    }

    draw() {
        this.p.clear();
        this.processGyroscopeData();
        this.updateWaves();
        this.displayWaves();
        this.displayText();
    }

processGyroscopeData() {
    if (this.dataManager.devices) {
        Object.values(this.dataManager.devices).forEach(device => {
            const betaMapped = this.p.map(device.beta, -90, 90, 0, this.p.width);
            const gammaMapped = this.p.map(device.gamma, -90, 90, 0, this.p.height);
            const alphaMapped = this.p.map(device.alpha, 0, 360, 10, 100);
            const deviceColor = this.getColorForDevice(device.color);

            // Always create a new wave with the latest data from the device
            this.waves.push(new Wave(this.p, betaMapped, gammaMapped, deviceColor, alphaMapped));
        });
    }
}

    getColorForDevice(colorName) {
        switch(colorName) {
            case 'red':
                return this.p.color(255, 0, 0);
            case 'green':
                return this.p.color(0, 255, 0);
            case 'blue':
                return this.p.color(0, 0, 255);
            default:
                return this.p.color(200); // Default to gray if unknown
        }
    }

    updateWaves() {
        this.waves.forEach(wave => wave.update());
        this.waves = this.waves.filter(wave => wave.isActive());
    }

    displayWaves() {
        this.waves.forEach(wave => {
            this.p.fill(wave.color);
            this.p.circle(wave.x, wave.y, wave.size);
            wave.color.setAlpha(255 - this.p.map(wave.size, 0, this.p.width / 2, 0, 255)); // Fading effect
        });
    }

    displayText() {
        this.p.fill(255);
        this.p.textSize(16);
        this.p.text(`Active waves: ${this.waves.length}`, 20, 30);
    }
}

class Wave {
    constructor(p, x, y, color, size) {
        this.p = p;
        this.x = x;
        this.y = y;
        this.size = size;
        this.color = color;
        this.growthRate = this.p.random(1, 5);
    }

    isActive() {
        return this.size < this.p.width / 2;
    }

    update() {
        this.size += this.growthRate;
    }

    updateColor(newColor) {
        this.color = newColor;
    }
}

